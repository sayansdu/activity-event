package kz.jazzsoft.bnd.event.adapter;import java.io.BufferedWriter;import java.io.File;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.InputStream;import java.io.Writer;import java.util.Properties;import org.apache.camel.CamelContext;import org.apache.camel.ConsumerTemplate;import org.apache.camel.Exchange;import org.apache.camel.Processor;import org.apache.camel.ProducerTemplate;import org.apache.camel.builder.RouteBuilder;import org.apache.camel.impl.DefaultCamelContext;import org.apache.camel.spi.Synchronization;/** * Created by: pavel.kurdyukov * Created: 17.01.13 11:23 * Copyright © LLP JazzSoft * Класс отправляет данные(любые) в подсистему интеграции с помощью Apache Camel */public class CamelSender {	    Util util = new Util();    ProducerTemplate pt;    ConsumerTemplate ct;    Object result;    private static final String FILE_NAME = "integration_config.properties";    private static final String FILE_CONTENT = "integration.url=http://localhost:8080/bnd-integration/rest/";    private static String url = "http://localhost:8080/bnd-integration/rest/";    public CamelSender() throws IOException {        File write = new File(FILE_NAME);        if(write.exists()) {            FileReader read = new FileReader(FILE_NAME);            Properties prop = new Properties();            prop.load(read);            url = prop.getProperty("integration.url");            read.close();        }        else{            write.createNewFile();            Writer writer = new BufferedWriter(new FileWriter(write));            writer.write(FILE_CONTENT);            writer.close();        }        RouteBuilder route = new RouteBuilder() {            @Override            public void configure() throws Exception {                from("direct:start").to(url + "sync").process(new Processor() {										                    public void process(Exchange exchange) throws Exception {                        result = exchange.getIn().getBody();                    }                });            }        };        CamelContext context = new DefaultCamelContext();        try {			context.start();			context.addRoutes(route);		} catch (Exception e) {			// TODO Auto-generated catch block			e.printStackTrace();		}                pt = context.createProducerTemplate();        ct = context.createConsumerTemplate();    }    /**     * Отправка данных асинхронно     * Доставка гарантированна     * Используется очередь ActiveMQ     *     * @param from - из какой подсистемы отправляется сообщение     * @param data - данные     */    public void sendAsync(final String from, byte[] data) throws Exception {        RouteBuilder route = new RouteBuilder() {            @Override            public void configure() throws Exception {                from("direct:start").setHeader("from", simple(from)).to(url + "async");            }        };        CamelContext context = new DefaultCamelContext();        context.start();        context.addRoutes(route);        ProducerTemplate pt = context.createProducerTemplate();        pt.asyncCallbackSendBody("direct:start", data, new Synchronization() {                        public void onComplete(Exchange exchange) {                try {                    exchange.getContext().stop();                } catch (Exception e) {                    e.printStackTrace();                }            }                        public void onFailure(Exchange exchange) {                try {                    exchange.getContext().stop();                } catch (Exception e) {                    e.printStackTrace();                }            }        });    }        /**     * Отправка данных     *     * @param from - из какой подсистемы отправляется сообщение     * @param data - данные     */    public byte[] send(final String from, byte[] data) throws Exception {        pt.sendBodyAndHeader("direct:start", data, "from", from);        InputStream is = (InputStream) result;        byte[] resultData = new byte[is.available()];        is.read(resultData);        is.close();        return resultData;    }}